<?php

namespace App\Models;

use App\Logic\Contracts\HasDslAdapterContract;
use App\Logic\Facades\EffectRunner;
use App\Logic\Process;
use App\Models\Casts\Behaviors;
use App\Models\Casts\LocaleString;
use App\Models\Interfaces\Stateful;
use App\Models\Services\ChatCreated;
use App\Models\Traits\HasBehaviors;
use App\Models\Traits\HasDslAdapter;
use App\Models\Traits\HasStates;
use Carbon\Carbon;
use Database\Factories\ChatFactory;
use Illuminate\Broadcasting\Channel;
use Illuminate\Database\Eloquent\BroadcastsEvents;
use Illuminate\Database\Eloquent\Collection;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use App\Models\Enums\ChatStatus;
use App\Models\Traits\HasOwner;
use App\Models\Interfaces\HasOwnerInterface;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;

/**
 * The Chat model represents a single active chat session created from a user application (Application).
 * Each chat tracks its state (created, published, finished, etc.), connected characters, and all stored messages or logic data (Memories).
 *
 * Serves as the runtime context for executing scenarios and logic flows tied to screens, controls, and participants.
 * Implements HasDslAdapterContract, allowing it to be used as a DSL adapter within the Process execution context.
 * This enables access to chat properties directly from DSL expressions (e.g., `chat.status`, `chat.title`, etc.).
 *
 * Also implements real-time broadcasting via Laravel Reverb for chat presence and frontend reactivity.
 *
 * Environment:
 * - Used by the Chat\Play Livewire component as the primary runtime container
 * - Passed into Process and exposed to DSL logic as `chat`
 * - Contains Memories generated by participants or logic
 * - Holds Characters (taken and free seats), used to manage participation
 * - Participates in real-time broadcasting (presence and chat updates)
 * - Used in Workshop and main UI to view or manage active chat instances
 *
 * @property null|int $id
 * @property null|int $application_id    - The application this chat is based on
 * @property null|string $title          - Display title for the chat
 * @property null|int $seats             - Total number of participant slots
 * @property null|int $masks_allowed     - Is users can add their masks as characters
 * @property null|ChatStatus $status     - Current chat status (e.g. Created, Published, Started)
 * @property null|Carbon $created_at
 * @property null|Carbon $updated_at
 *
 * @property-read null|Application $application     - The parent application used to create this chat
 * @property-read Collection<int, Memory> $memories  - All messages or stored entries linked to the chat
 * @property-read Collection<int, Character> $characters   - TODO All characters (both free and taken)
 * @property-read Collection<int, Character> $freeSeats - TODO Available character slots (user_id is null)
 * @property-read Collection<int, Character> $takenSeats - TODO Assigned participant seats (user_id is not null)
 * @property-read Collection<int, ChatScreenState> $screenStates - Assigned participant seats (user_id is not null)
 */
class Chat extends Model implements HasOwnerInterface, HasDslAdapterContract, Stateful
{
    /** @use HasFactory<ChatFactory> */
    use HasOwner, HasStates, HasBehaviors, HasFactory, BroadcastsEvents, HasDslAdapter;

    protected $fillable = [
        'user_id', 'application_id', 'title', 'status', 'seats',
        'masks_allowed', 'states', 'behaviors', 'behaviorsString'
    ];

    protected $casts = [
        'masks_allowed' => 'boolean',
        'status' => ChatStatus::class,
        'states' => 'array',
        'behaviors' => Behaviors::class,
        'title' => LocaleString::class
    ];

    public function application(): BelongsTo
    {
        return $this->belongsTo(Application::class);
    }

    public function memories(): HasMany
    {
        return $this->hasMany(Memory::class);
    }

    public function characters(): HasMany
    {
        return $this->hasMany(Character::class);
    }

    public function freeSeats(): HasMany
    {
        return $this->characters()->whereNull('user_id');
    }

    public function takenSeats(): HasMany
    {
        return $this->characters()
            ->whereNotNull('user_id')->where('is_confirmed', true);
    }

    public function allowedSeatsCount(): int
    {
        return $this->seats - $this->takenSeats()->count();
    }

    public function screenStates(): HasMany
    {
        return $this->hasMany(ChatScreenState::class);
    }

    public static function boot(): void
    {
        parent::boot();
        static::creating(function(self $model) {
            self::assignCurrentUser($model);
            if (!$application = $model->application) {
                throw new \RuntimeException('Cannot initialize chat: chat has no associated application.');
            }
            foreach(['states', 'behaviors', 'seats', 'masks_allowed'] as $field) {
                $model->$field = $application->$field;
            }
        });
        static::created(function(self $model) {
            ChatCreated::handle($model);
            $application = $model->application;
            if ($application->init) {
                EffectRunner::run($application->init, new Process([
                    'chat' => $model,
                ]));
            }
        });
        static::saving([self::class, 'savingAllStates']);
    }

    public function broadcastOn(string $event): array
    {
        return [new Channel('chats.index')];
    }

    public function broadcastAs(string $event): ?string
    {
        return 'refresh';
    }

    public function broadcastWith(string $event): array
    {
        return  ['id' => $this->id];
    }
}
