<?php

namespace App\Models;

use App\Logic\Contracts\HasDslAdapterContract;
use App\Models\Interfaces\Stateful;
use App\Models\Traits\HasDslAdapter;
use App\Models\Traits\HasStates;
use Carbon\Carbon;
use Database\Factories\ChatFactory;
use Illuminate\Broadcasting\Channel;
use Illuminate\Database\Eloquent\BroadcastsEvents;
use Illuminate\Database\Eloquent\Collection;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use App\Models\Enums\ChatStatus;
use App\Models\Traits\HasOwner;
use App\Models\Interfaces\HasOwnerInterface;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;

/**
 * The Chat model represents a single active chat session created from a user application (Application).
 * Each chat tracks its state (created, published, finished, etc.), connected members, and all stored messages or logic data (Memories).
 *
 * Serves as the runtime context for executing scenarios and logic flows tied to screens, controls, and participants.
 * Implements HasDslAdapterContract, allowing it to be used as a DSL adapter within the Process execution context.
 * This enables access to chat properties directly from DSL expressions (e.g., `chat.status`, `chat.title`, etc.).
 *
 * Also implements real-time broadcasting via Laravel Reverb for chat presence and frontend reactivity.
 *
 * Environment:
 * - Used by the Chat\Play Livewire component as the primary runtime container
 * - Passed into Process and exposed to DSL logic as `chat`
 * - Contains Memories generated by participants or logic
 * - Holds Members (taken and free seats), used to manage participation
 * - Participates in real-time broadcasting (presence and chat updates)
 * - Used in Workshop and main UI to view or manage active chat instances
 *
 * @property null|int $id
 * @property null|int $application_id    - The application this chat is based on
 * @property null|string $title          - Display title for the chat
 * @property null|int $seats             - Total number of participant slots
 * @property null|ChatStatus $status     - Current chat status (e.g. Created, Published, Started)
 * @property null|Carbon $created_at
 * @property null|Carbon $updated_at
 *
 * @property-read null|Application $application     - The parent application used to create this chat
 * @property-read Collection<int, Memory> $memories  - All messages or stored entries linked to the chat
 * @property-read Collection<int, Member> $members   - All participant seats (both free and taken)
 * @property-read Collection<int, Member> $freeSeats - Available member slots (user_id is null)
 * @property-read Collection<int, Member> $takenSeats - Assigned participant seats (user_id is not null)
 * @property-read Collection<int, ChatScreenState> $screenStates - Assigned participant seats (user_id is not null)
 */
class Chat extends Model implements HasOwnerInterface, HasDslAdapterContract, Stateful
{
    /** @use HasFactory<ChatFactory> */
    use HasOwner, HasStates, HasFactory, BroadcastsEvents, HasDslAdapter;

    protected $fillable = [
        'user_id', 'application_id', 'title', 'status', 'states'
    ];

    protected $casts = [
        'status' => ChatStatus::class,
        'states' => 'array'
    ];

    public function application(): BelongsTo
    {
        return $this->belongsTo(Application::class);
    }

    public function memories(): HasMany
    {
        return $this->hasMany(Memory::class);
    }

    public function members(): HasMany
    {
        return $this->hasMany(Member::class);
    }

    public function freeSeats(): HasMany
    {
        return $this->members()->whereNull('user_id');
    }

    public function takenSeats(): HasMany
    {
        return $this->members()->whereNotNull('user_id');
    }

    public function allowedSeatsCount(): int
    {
        return $this->seats - $this->takenSeats()->count();
    }

    public function screenStates(): HasMany
    {
        return $this->hasMany(ChatScreenState::class);
    }

    public static function boot(): void
    {
        parent::boot();
        static::creating([self::class, 'assignCurrentUser']);
        static::created(function(self $model) {
            $application = $model->application;
            if (!$application) {
                throw new \RuntimeException('Cannot initialize chat: chat has no associated application.');
            }
            $screens = $application->screens;
            foreach ($screens as $screen) {
                ChatScreenState::create([
                    'chat_id'   => $model->id,
                    'screen_id' => $screen->id,
                    'states'    => $screen->states ?? [],
                ]);
            }
        });
        static::saving(function(self $model) {
            if ($model->isDirty('states')) {
                $states = $model->states ?: [];
                foreach ($states as $key => $state) {
                    $model->validateState($key, $state);
                }
            }
        });
    }

    public function broadcastOn(string $event): array
    {
        return [new Channel('chats.index')];
    }

    public function broadcastAs(string $event): ?string
    {
        return 'refresh';
    }

    public function broadcastWith(string $event): array
    {
        return  ['id' => $this->id];
    }
}
